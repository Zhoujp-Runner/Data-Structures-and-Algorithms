/***********************************************************************
 * Copyright 2023 by Zhou Junping
 *
 * @file     class1.cpp
 * @brief    这个文件用于本人学习数据结构与算法
 *
 * @details
 * 该文件写的是左程云算法视频的中级提升课程中的内容：
 * 1.滑动窗口的技巧
 *      a.绳子最多能覆盖几个点
 * 2.打表
 *      a.最少使用的袋子数量
 * 最近修改日期：2023-09-10
 *
 * @author   Zhou Junping
 * @email    zhoujunpingnn@gmail.com
 * @version  1.0
 * @data     2023-9-10
 *
 */


#include <iostream>
#include <vector>

using namespace std;

/******************滑动窗口的技巧：左右两个边界都不会回退的题目********************
 * 绳子最多能覆盖几个点
 * 给定一个数组，数组中的每个元素表示一个点在数轴上的位置
 * 给定一个整数，代表一根绳子的长度
 * 绳子可以在数轴上来回移动
 * 请问绳子最多能够覆盖几个点
 */
int process1(vector<int> arr, int length) {
    int left = 0;  // 绳子的左端点（滑动窗口的左边界）
    int right = 1;  // 绳子的右端点（滑动窗口的右边界）
    int max_points = 0;  // 最大能被覆盖的点的数量
    while (right <= arr.size()) {
        if (right == arr.size()) {  // 如果右端点此时已经来到了末尾的下一个元素位置，说明绳子能把之前的点都包括进去
            max_points = max(max_points, right - left);  // 由于是最后一个点的下一个元素，所以不需要+1
            right++;
        }

        if (arr[right] - arr[left] < length) {  // 如果当前左右两端点之间的距离小于绳子的长度，那么就让右端点向右移动
            right++;
        } else if (arr[right] - arr[left] == length) {  // 如果此时距离正好等于绳子的长度，那么就让左端点向右移动
            max_points = max(max_points, left - right + 1);  // 此时，右端点应该被计入点的数量，所以要+1
            left++;
        } else {  // 如果此时距离大于绳子的长度，那么就让左端点向右移动
            max_points = max(max_points, left - right);  // 此时，右端点不应该被计入点的数量，所以不要+1
            left++;
        }

    }

    return max_points;
}


/*****************************打表*****************************
 * 先用常规的方法写出解法
 * 然后自己写样例进行测试（可以借鉴对数器）
 * 根据常规解法，找出输入与输出之间的规律
 * 最终直接根据规律写一个代码
 * 这样子做，时间复杂度直接为O(1)
 *
 * 该方法适用于部分输入单一输出也单一的题目
 * 其内部蕴含一定的数学规律，但是一般根本想不到
 * 所以通过先写出常规解法的方式，寻找输入与输出之间的关系
 */
/**
 * 最少使用的袋子数量
 * 给定一个整数N，表示一共有N个苹果
 * 现在，只有两种袋子，一种袋子能装8个苹果，一种袋子能装6个苹果，一种袋子能装8个苹果
 * 要求使用袋子恰好能够装完所有的苹果
 * 求最少的袋子使用数量，如果不存在恰好装完的情况则返回-1
 *
 * 结题思路也很简单，先尽可能用容量大的袋子装
 * 再看看剩下的苹果能否用容量小的袋子恰好装掉
 * 如果可以，那么返回总的袋子数；如果不可以就将大袋子数量减一，继续尝试
 */
int process2(int N) {
    if (N % 2 == 1) {  // 如果是奇数肯定不能装
        return -1;
    }

    int num8 = N / 8;
    int res =  N % 8;

    // 这里可以进行优化的，不需要将所有的8容量袋子全部减完
    // 如果用完8袋子之后，剩余的苹果数量已经大于24，那么就没有试下去的必要了，肯定不可能恰好装完
    // 因为剩余的苹果数量大于24意味着，已经将8袋子减去3个了，但是注意，这3个8袋子完全可以使用4个6袋子装完，所以此时没有试下去的必要了
    // 举个例子，假设此时剩余3个苹果，三次过后剩余27个苹果，那么其中24个苹果可以恰好被6装掉，又剩下3个，回到了最初的情况
    // 24是6和8的最小公倍数
    while (res < 24 && num8 >= 0) {
        if (res % 6 == 0) {  // 一旦第一次恰好可装，就可以直接返回了，因为此时使用的8袋子数量最大
            return num8 + res / 6;
        }
        num8--;
        res += 8;
    }

    return -1;
}

/**
 * 使用打表，上述的代码是常规代码
 * 将0-100作为输入，此时输出的规律就能发现了
 * 这里我直接将打表后的代码写出来，可以自己使用process2看一下规律
 */
int process2_(int N) {
    if (N % 2 == 1) {  // 奇数直接返回
        return -1;
    }

    if (N < 18) {
        return N == 0 ? 0 :
               (N == 6 || N == 8) ? 1 :
               (N == 12 || N == 14 || N == 16) ? 2 : -1;
    }

    return (N - 18) / 8 + 3;
}



int main() {
    for (int i = 0; i < 100; ++i) {
        if (process2(i) != process2_(i)) {
            cout << "ops" << endl;
        }
    }
    return 0;
}
