/***********************************************************************
 * Copyright 2023 by Zhou Junping
 *
 * @file     big_data_problem.cpp
 * @brief    这个文件用于本人学习数据结构与算法
 *
 * @details
 * 该文件写的是左程云算法视频的基础提升课程中关于大数据题目的内容：
 * 1. 笔记
 *      a.大数据题目的解题技巧（一共有七条）
 *      b.一些问题（有关解题技巧中后三条——位图、分段、堆的一些示例）
 * 最近修改日期：2023-08-26
 *
 * @author   Zhou Junping
 * @email    zhoujunpingnn@gmail.com
 * @version  1.0
 * @data     2023-8-25
 *
 */

/*********************************笔记*********************************
 * *********************大数据题目的解题技巧******************* *
 *      1）哈希函数可以吧数据按照种类均匀分流
 *      2）布隆过滤器用于集合的建立与查询，并可以节省大量空间
 *      3）一致性哈希解决数据服务器负载管理的问题
 *      4）利用并查集结构做岛问题的并行计算
 *      5）位图解决某一范围上数字的出现情况，并可以节省大量空间
 *      6）利用分段统计思想，并进一步节省大量空间
 *      7）利用堆、外排序来做多个处理单元的结果合并
 *      ps. 前五个可以看之前的笔记，都有讲过，该部分笔记从第5点开始记录
 *      面试过程中，大数据问题（或者说资源限制类题目）都可以用上述5个方法去解，甚至哈希函数分流的思想是万能的
 *
 * *********************问题1（位图+分段统计）******************* *
 *      【原题】32位无符号整数的范围是0~4,294,967,295，现在有一个正好包含40亿个无符号整数的文件，所以在整个范围中必然存在没出现过的数。可以使用
 *      最多1GB内存，怎么找到所有未出现过的数
 *      【进阶1】内存限制为3KB，但是只用找到一个没出现过的数即可
 *      【进阶2】内存1GB，怎么找到所有出现过两次的数
 *      【进阶3】内存3KB，找到40亿个数中的中位数
 *
 *      【原题解】我们不用具体数字进行统计，我们只对数字的范围进行一一对应
 *      由于一个无符号整型数字由四个字节构成，一个字节上有8位二进制位，所以我们只需要2^32位二进制位，就可以记录所有的数字出现的可能性，需要的
 *      空间为2^32 / 8 B（字节） = 512 MB 的空间，
 *      位图的代码在 **hash_structure.cpp** 里面，原问题得解
 *
 *      【进阶1】我们现在不对具体某个数统计是否出现，我们统计某一个范围内的数字出现的次数
 *      3KB的空间如果全部用来申请整型数组，可以最多申请3KB/4B = 768个整型数字，我们需要让整型数字的个数能够整除2^32（因为现在整型数组作用是将
 *      0 ~ 2^32-1范围均分，也就是说，如果整型数组的长度为N，那就要使其能够被均分为N个范围，所以需要整除），所以我们寻找小于等于768的，最接近的
 *      数字2^y，可知当y=9时，2^9=512最接近768.所以我们将 0 ~ 2^32-1 范围均分为512份，每份里面应当有8388608个数，整型数组的第i个元素，统计
 *      的是 8388608*i ~ 8388608*(i+1)-1 范围上数字出现的次数。由于文件包含的是40亿个无符号整数，所以至少有一个区间上的数字个数少于8388608
 *      选出该区间。然后，继续用这3KB的空间申请整型数组，将该区间均分，统计数字出现次数，不断循环，直到找到该数字为止。
 *
 *      【进阶2】原始的位图由于表示一个数字只有1位，所以不能统计出现次数，只能统计是否出现
 *      所以我们可以用2位表示一个数字出现的状态，那么表示2^32个数所需的内存正好是1GB，就可以统计出现次数了
 *
 *      【进阶3】40亿个数，如果有序，那么中位数出现在第20亿个数上
 *      和进阶1一样统计词频，统计完一次之后，会得到一个数组，然后从数组第一个元素开始累加，当加上第i个元素后，累加和恰好超过20亿时，说明此时中位数
 *      出现在当前的第i个元素所表示的区间上，记录前i-1个元素的累加和M，然后继续对i区间分段统计词频，同样从头开始累加，但是此时累加的初始值为m，当
 *      累加和超过20亿时重复上述操作，直到找到第20亿个数。
 *
 * **********************问题2（堆）******************** *
 *      有一个包含100亿个URL的大文件，假设每个URL占用64B，请找出其中所有重复的URL
 *      【补充】某搜索公司一天的用户搜索词汇是海量的（百亿数据量），请设计一种求出每天热门TOP100词汇的可行方法
 *
 *      原问题可以用哈希函数分流，哈希函数的值对m取模，将URL分为m份，分别对每一份中的URL进行统计；也可以使用布隆过滤器（但是布隆过滤器会有失误率，
 *      所以不是很建议）我们现在主要关心补充问题，补充问题建立在我们将URL分为m份并分别统计完其中的URL出现次数的基础上
 *
 *      【补充】很简单，m份URL构成m个大根堆，称为m个子堆；然后将每一个堆的堆顶作为一个节点，构成一个具有m个节点的大根堆，称之为总堆，我们，每次取总
 *      堆的堆顶元素，并更新相应的子堆与总堆，取100次就行了。
 *
 * **********************问题3（堆+分段）********************** *
 *      （腾讯）有一个10G的文件，里面都是无序的整型数字，给你5G的内存，输出一个新的10G文件，里面的数是原10G文件中有序排列后的结果
 *      ps.10G文件中的10G指的是硬盘空间，5G指的是程序内存，这个5G也只是代指，也可以更小，只要知道解法就行
 *
 *      【方法一】建立一个堆，每个节点上有两个记录，一个是数的值，一个是数出现的次数。5G内存全部用来建立这个堆，假设一共可以建立M个节点。整型数字的范围
 *      大小为2^32，那就将这个范围分为 2^32 / M 个小范围，每个小范围上有M个数，然后从最小的子区间开始统计M个数并放入构建完成的小根堆，遍历完文件之后
 *      将这个小根堆上的数有序输出到文件中（注意如果出现次数为2，意思是最终输出到文件里的该数字有两个），继续统计下一个小区间，循环往复，直到10GB全统计完
 *
 *      【方法二】方法一有一个缺点，如果10G中的数不考虑重复，其数的个数远远小于整型的范围大小，那就造成了，当你使用方法一的时候，很多区间上都可能几乎
 *      没有数，或者数出现很少，但是每一个区间都需要遍历一次文件进行统计，那么时间开销就完全浪费了，所以我们换一种方法。
 *      和方法一一样，我们需要建立堆，假设节点数目为M，当我们遍历一次文件，如果能够找到当前文件中未输出的最小（最大）的M个数，时间开销就远小于方法一
 *      因为此时，范围由整型数字范围降低到了文件中数字的范围。
 *      方法是，建立大根堆。
 *      第一次遍历文件时，堆中的节点不满M时，来新的数字就进堆；
 *      当堆中的节点已经达到M时，遍历到一个新的数字X时，将其与堆顶元素进行比较，若大于堆顶元素则跳过X，若小于堆顶元素，则将堆顶元素删除，并将X置于堆顶
 *      向下调整堆。（因为堆顶元素大于其他堆中元素，所以如果X大于堆顶元素，那X一定不是最小的M个数；如果X小于堆顶元素，那么堆顶元素一定不是最小的M个数，
 *      而X可能是最小的M个数，所以要将堆顶元素弹出，将X插入堆）
 *      遍历完文件之后，堆中所留着的M个数字就是文件中最小的M个数字，将其输出。
 *      第二次遍历时，由于是大根堆，所以我们只统计大于上一次遍历结束后大根堆堆顶元素的数字即可。
 *
 */